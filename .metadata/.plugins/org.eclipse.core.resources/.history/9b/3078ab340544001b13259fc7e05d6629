package edu.uwm.cs351.util;

import java.util.Comparator;



/**
 * An class with utility code for sorting and using sorted arrays.
 * @param K type of keys
 */
public class SortUtils<T>{
	private Comparator<T> _comparator;
	
	public SortUtils(Comparator<T> c) {
		_comparator = c;
	}
	
	/** merge sort the elements of the array
	 * @param array must not be null
	 */
	public void mergeSort(T[] array) {
		mergeSortKeep(0,array.length,array,array.clone());
	}
	
	/** Merge sort "in" array between lo and hi and put results in "out".
	 * The "in" array will be used for scratch in the same range.
	 * @param lo >= 0
	 * @param hi >= lo
	 * @param in must not be null
	 * @param out must not be null or same as in
	 */
	public void mergeSortMove(int lo, int hi, T[] in, T[] out) {
		// TODO
		int mid= (lo+hi)/2;
		
		if(lo>hi)
			return;
		
		if(lo<0)
			return;
		
		if(hi==lo) 
			return;
		
		if(in==null || out==null) 
			return;
		
		
		if(lo+1==hi) {
			out[lo]=in[lo];
			return;
		}
		
		mergeSortKeep(lo, mid, in, out);
		mergeSortKeep(mid, hi, in, out);
		merge(lo, mid, hi, in, out);
		
		
	}

	/** merge sort "in" array between lo and hi in place using temp array for scratch
	 * @param lo >= 0
	 * @param hi >= lo
	 * @param data must not be null, length >= hi
	 * @param temp must not be null or same as data, length >= hi
	 */
	public void mergeSortKeep(int lo, int hi, T[] data, T[] temp) {
		// TODO
		int mid = (lo + hi)/ 2;
		
		if(lo > hi)
			return;
		
		if(lo<0)
			return;
		
		if(data==null || temp==null) 
			return;
		
		if (lo == hi)
			return;
		
		if (lo+1 == hi)
			return;
		
		if(hi>data.length|| temp.length< hi) 
			return;
		
	
		mergeSortMove(lo, mid, data, temp);
		mergeSortMove(mid, hi, data, temp);
		merge(lo, mid, hi, temp, data);
		
		
		
		
	}
	
	/** merge sorted lists in [lo,mid) and [mid,hi) in "in" into [lo,hi) in "out".
	 * @param lo >= 0
	 * @param mid >= lo
	 * @param hi >= mid
	 * @param in must not be null, length >= hi
	 * @param out must not be null or same as in, length >= hi
	 */
	public void merge(int lo, int mid, int hi, T[] in, T[] out) {
		// TODO
		int first_lo = lo; 
		int second_lo = mid;
		int first_hi = mid;
		int second_hi = hi;
		
		if(lo>hi) 
			return;
		
		if(lo<0)
			return;
		
		if(in==null || out==null) 
			return;
		
		if(hi>in.length|| out.length< hi)
			return;
		
		
		
		while (first_lo < first_hi && second_lo < second_hi) {
			if (_comparator.compare(in[first_lo], in[second_lo]) < 0) {
				out[lo++] = in[first_lo++];
			} else {
				out[lo++] = in[second_lo++];
			}
		}
		while (first_lo < first_hi) {
			out[lo++] = in[first_lo++];
		}
		while (second_lo < second_hi) {
			out[lo++] = in[second_lo++];
		}
		
	}
	
	/** Write elements from sorted array in range [lo1,hi1)
	 * into out [lo1,...] as long as they
	 * don't occur in sorted array rem in range [lo2,hi2).  
	 * The result (out) will also be sorted.  
	 * @param lo1 >= 0
	 * @param hi1 >= lo1
	 * @param lo2 >= 0
	 * @param hi2 >= lo2
	 * @param in must not be null, length >= hi1
	 * @param rem must not be null, length >= hi2
	 * @param out must not be null, length >= hi1.
	 * The array out may be the same as the in, but not the same as rem.
	 * @return the index after the last element added into out.
	 */
	public int difference(int lo1, int hi1, int lo2, int hi2, T[] in, T[] rem, T[] out) {
		int first_lo = lo1;

		while (lo1 < hi1 && lo2 < hi2) {
			if (_comparator.compare(in[lo1], rem[lo2]) < 0) {
				out[first_lo++] = in[lo1++];
			} 
			else 
				if(_comparator.compare(in[lo1], rem[lo2]) >0) {
				
				lo2++;
				
			}else
			{
				lo1++;
			}
		}
		
		while(lo1<hi1) {
			out[first_lo++] = in[lo1++];
		}
		
		return first_lo;
		// TODO
	}
	
	/**
	 * Remove duplicate elements (ones with 0 comparison)
	 * from a sorted array.  If the array is not sorted,
	 * it won't necessarily work correctly.
	 * @param array must not be null
	 * @return number of unique elements.
	 */
	public int uniq(T[] array) {
		return uniq(0,array.length,array,array);
	}
	
	/**
	 * Remove duplicate elements (one with 0 comparison)
	 * from a sorted array range [lo,hi), writing the unique elements to
	 * the second array [lo,...).
	 * @param lo >= 0
	 * @param hi >= lo
	 * @param in must not be null
	 * @param out must not be null.  This array may be the same as in without problems.
	 * @return index after unique elements
	 */
	public int uniq(int lo, int hi, T[] in, T[] out) {
		int counter;
		
		if(lo==hi)
			return hi;
		
		out[lo]=in[lo];
		
		counter=lo;
		lo++;
		while(lo<hi) {
			if(_comparator.compare(out[counter], in[lo])<0) {
				counter++;
				out[counter]=in[lo];	
			}
			lo++;
		}
		return ++counter; // TODO
	}
}
